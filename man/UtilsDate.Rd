% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UtilsDate.R
\name{UtilsDate}
\alias{UtilsDate}
\title{Parse Dates to Standard Format}
\description{
Parse Dates to Standard Format

Parse Dates to Standard Format
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-UtilsDate-std_date}{\code{UtilsDate$std_date()}}
\item \href{#method-UtilsDate-dttm_to_dt}{\code{UtilsDate$dttm_to_dt()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UtilsDate-std_date"></a>}}
\if{latex}{\out{\hypertarget{method-UtilsDate-std_date}{}}}
\subsection{Method \code{std_date()}}{
\code{std_dates} standardizes a date vector and returns a vector in \code{Date} or
\code{POSIXct} format, depending on whether there is sub-daily information
available in the data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UtilsDate$std_date(
  x,
  force = c("none", "dt", "dttm"),
  orders = c("mdy", "dmy", "ymd", "mdyr", "dmyr", "ymdr", "mdyR", "dmyR", "ymdR", "mdyT",
    "dmyT", "ymdT", "mdyTz", "dmyTz", "ymdTz", "Tmdyz", "Tdmyz", "Tymdz", "mdyRz",
    "dmyRz", "ymdRz", "mdyrz", "dmyrz", "ymdrz", "Tmdy", "Tdmy", "Tymd", "Tmdyz",
    "Tdmyz", "Tymdz"),
  tz_heuristic = c(5L, 6L),
  warn = TRUE,
  train = TRUE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{A vector of \code{character} dates, \code{Date}s, or \code{POSIXt}s}

\item{\code{force}}{Whether to force conversion to \code{Date} (\code{force = "dt"}) or
\code{POSIXct} (\code{force = "dttm"}). The default is no forcing (\code{force = "none"}).}

\item{\code{orders}}{A \code{character} vector of date-time formats. Each order
string is a series of formatting characters as listed in
\code{\link[base:strptime]{base::strptime()}} but might not include the
"\%" prefix. For example, "ymd" will match all the possible dates in
year, month, day order. Formatting orders might include arbitrary
separators. These are discarded. See details of
\code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}
for the implemented formats. If multiple order strings are supplied,
the order of applied formats is determined by the \code{select_formats}
parameter in
\code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}
(if passed via dots).}

\item{\code{tz_heuristic}}{Hours to consider in determining presence of sub-daily
information. Only exact hours (i.e. 5:00:00) will be combined. The default
corresponds to accidental encoding of the CST-UTC offset as hours.}

\item{\code{warn}}{Should warnings be thrown when necessary? \code{FALSE} will
suppress all warnings in the conversion process.}

\item{\code{train}}{\code{logical}, default \code{TRUE}. Whether to train formats on a
subset of the input vector. The result of this is that supplied orders
are sorted according to performance on this training set, which
commonly results in increased performance. Please note that even
when \code{train = FALSE} (and \code{exact = FALSE}, if passed via dots)
guessing of the actual formats is still performed on a pseudo-random
subset of the original input vector. This might result in
\verb{⁠All formats failed to parse}⁠ error.See notes
in \code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}.}

\item{\code{...}}{Additional arguments to pass to
\code{\link[janitor:convert_to_date]{convert_to_datetime()}}. These
will, in turn, be passed to further methods, including
\code{\link[janitor:excel_numeric_to_date]{excel_numeric_to_date()}},
\code{\link[lubridate:parse_date_time]{parse_date_time()}}, and
\code{\link[base:as.POSIXct]{as.POSIXct()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{Date} or \code{POSIXct} vector
Coerce Datetimes to Dates if No Information is Lost

\code{dttm_to_dt()} converts \code{POSIXt} objects to \code{Date} objects when there is no
additional information contained in the \code{POSIXt} format (i.e. there is no
sub-daily information).

Specifically, \code{dttm_to_dt} checks whether all sub-daily information is the
same for each value in the datetime vector. If so, no additional information
is gained by using a \code{POSIXt} format over the simpler \code{Date} format, and
the data is coerced.

If the input is scalar (i.e. has length \code{1L}), then no conversion is
attempted
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UtilsDate-dttm_to_dt"></a>}}
\if{latex}{\out{\hypertarget{method-UtilsDate-dttm_to_dt}{}}}
\subsection{Method \code{dttm_to_dt()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UtilsDate$dttm_to_dt(
  x,
  force = c("none", "dt", "dttm"),
  tz_heuristic = c(0L, 5L, 6L)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{A \code{Date}, \code{POSIXct} or \code{POSIXlt} (i.e. a datetime) vector}

\item{\code{force}}{Whether to force conversion to \code{Date} (\code{force = "dt"}) or
\code{POSIXct} (\code{force = "dttm"}). The default is no forcing (\code{force = "none"}).}

\item{\code{tz_heuristic}}{Hours to consider in determining presence of sub-daily
information. Only exact hours (i.e. 5:00:00) will be combined. The default
corresponds to accidental encoding of the CST-UTC offset as hours.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Either a \code{POSIXct} vector or a \code{Date} vector
}
}
}
