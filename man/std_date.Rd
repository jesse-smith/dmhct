% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{std_date}
\alias{std_date}
\title{Parse Dates to Standard Format}
\usage{
std_date(
  x,
  force = c("none", "dt", "dttm"),
  orders = c("mdy", "dmy", "ymd", "mdyr", "dmyr", "ymdr", "mdyR", "dmyR", "ymdR", "mdyT",
    "dmyT", "ymdT", "mdyTz", "dmyTz", "ymdTz", "Tmdyz", "Tdmyz", "Tymdz", "mdyRz",
    "dmyRz", "ymdRz", "mdyrz", "dmyrz", "ymdrz", "Tmdy", "Tdmy", "Tymd", "Tmdyz",
    "Tdmyz", "Tymdz"),
  tz_heuristic = c(5L, 6L),
  warn = TRUE,
  train = TRUE,
  na = c("^$", "N/?A", "ONGOING"),
  range_value = c("start", "end", "na"),
  range_sep = c("-", "to", ","),
  ...
)
}
\arguments{
\item{x}{A vector of \code{character} dates, \code{Date}s, or \code{POSIXt}s}

\item{force}{Whether to force conversion to \code{Date} (\code{force = "dt"}) or
\code{POSIXct} (\code{force = "dttm"}). The default is no forcing (\code{force = "none"}).}

\item{orders}{A \code{character} vector of date-time formats. Each order
string is a series of formatting characters as listed in
\code{\link[base:strptime]{base::strptime()}} but might not include the
"\%" prefix. For example, "ymd" will match all the possible dates in
year, month, day order. Formatting orders might include arbitrary
separators. These are discarded. See details of
\code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}
for the implemented formats. If multiple order strings are supplied,
the order of applied formats is determined by the \code{select_formats}
parameter in
\code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}
(if passed via dots).}

\item{tz_heuristic}{Hours to consider in determining presence of sub-daily
information. Only exact hours (i.e. 5:00:00) will be combined. The default
corresponds to accidental encoding of the CST-UTC offset as hours.}

\item{warn}{Should warnings be thrown when necessary? \code{FALSE} will
suppress all warnings in the conversion process.}

\item{train}{\code{logical}, default \code{TRUE}. Whether to train formats on a
subset of the input vector. The result of this is that supplied orders
are sorted according to performance on this training set, which
commonly results in increased performance. Please note that even
when \code{train = FALSE} (and \code{exact = FALSE}, if passed via dots)
guessing of the actual formats is still performed on a pseudo-random
subset of the original input vector. This might result in
\verb{⁠All formats failed to parse}⁠ error.See notes
in \code{\link[lubridate:parse_date_time]{lubridate::parse_date_time()}}.}

\item{na}{Regular expressions to convert to \code{NA}}

\item{range_value}{The value to use if the date is given as a range; can be
the start date, the end date, or fill with \code{NA}}

\item{range_sep}{Separators used for date ranges}

\item{...}{Additional arguments to pass to
\code{\link[janitor:convert_to_date]{convert_to_datetime()}}. These
will, in turn, be passed to further methods, including
\code{\link[janitor:excel_numeric_to_date]{excel_numeric_to_date()}},
\code{\link[lubridate:parse_date_time]{parse_date_time()}}, and
\code{\link[base:as.POSIXct]{as.POSIXct()}}.}
}
\value{
A \code{Date} or \code{POSIXct} vector
}
\description{
\code{std_date} standardizes a date vector and returns a vector in \code{Date} or
\code{POSIXct} format, depending on whether there is sub-daily information
available in the data.
}
